import glob
import io
import os
import shutil
import sys
import urllib.request
import xml.etree.ElementTree as et
from pathlib import Path
from tkinter import StringVar, IntVar, Grid, Entry, Label, Listbox, Toplevel, Text, Button, Radiobutton, Frame, Tk, \
    filedialog, messagebox, font

from openpyxl import load_workbook, Workbook
from openpyxl.styles import PatternFill

RIMWORLD_VERSION = '1.1'
LANGUAGE = 'RimWaldo (림왈도)'  # 'Korean (한국어)'

EXTRACTABLE_DIRS = ["Defs", "Languages", "Patches"]
CONFIG_VERSION = 5
EXTRACTOR_VERSION = "0.10.3"
WORD_NEWLINE = '\n'
WORD_BACKSLASH = '\\'

EXPORT_XML_PLAIN = 0
EXPORT_XML_ANNOTATION = 1
EXPORT_XLSX = 2


class Configures:
    def __init__(self, fileName='config.dat'):
        if not os.path.exists(fileName):
            self.write(isReset=True)
            return

        with open(fileName, 'r', encoding='UTF8') as fin:
            configs = fin.read().split('\n')

        if CONFIG_VERSION != int(configs[3]):
            if messagebox.askyesno("사용자 설정 초기화",
                                   "config.dat 파일의 형식이 변경되어 설정 초기화가 필요합니다.\n" +
                                   "초기화 진행 시 사용자가 변경한 설정이 유실됩니다.\n" +
                                   "필요할 경우 초기화를 진행하기 전에 백업해 주세요.\n설정 초기화를 진행할까요?"):
                self.write(isReset=True)
                return
            else:
                exit(0)

        # Saved Configs
        self.gameDir = StringVar(value=configs[5])
        self.modDir = StringVar(value=configs[7])
        self.definedExcludes = configs[9].replace(' ', '').split('/')
        self.definedIncludes = configs[11].replace(' ', '').split('/')
        self.exportType = IntVar(value=int(configs[13]))
        self.collisionOption = IntVar(value=int(configs[15]))

        # Volatile Configs
        self.extractPathList = []
        self.modName = ""
        self.excludes = []
        self.defaults = []
        self.includes = []
        self.excludeHide = []
        self.defaultHide = []
        self.includeHide = []
        self.exportDirName = StringVar()
        self.exportFileName = StringVar()
        self.dict_tags_text = {}
        self.list_strings = []

    def write(self, isReset=False, fileName='config.dat'):
        if isReset:
            self.gameDir = StringVar(value="C:/Program Files (x86)/Steam/steamapps/common/RimWorld")
            self.modDir = StringVar(value="C:/Program Files (x86)/Steam/steamapps/workshop/content/294100")
            self.definedExcludes = []
            self.definedIncludes = "label/description/customLabel/rulesStrings/slateRef/reportString/jobString/verb/labelNoun" \
                                   "/gerund/helpText/letterText/labelFemale/labelPlural/text/labelShort/letterLabel" \
                                   "/baseInspectLine/beginLetter/rejectInputMessage/deathMessage/beginLetterLabel" \
                                   "/recoveryMessage/endMessage/gerundLabel/pawnLabel/onMapInstruction/labelNounPretty" \
                                   "/labelForFullStatList/pawnSingular/pawnsPlural/labelSolidTendedWell/labelTendedWell" \
                                   "/labelTendedWellInner/destroyedLabel/permanentLabel/skillLabel/graphLabelY/formatString" \
                                   "/meatLabel/headerTip/labelMale/ingestCommandString/ingestReportString/useLabel" \
                                   "/descriptionFuture/destroyedOutLabel/leaderTitle/textEnemy/textWillArrive/arrivalTextEnemy" \
                                   "/letterLabelEnemy/arrivedLetter/stuffAdjective/textFriendly/arrivalTextFriendly" \
                                   "/letterLabelFriendly/name/summary/labelMechanoids/approachingReportString" \
                                   "/approachOrderString/fuelGizmoLabel/fuelLabel/outOfFuelMessage/labelSocial" \
                                   "/calledOffMessage/finishedMessage/discoverLetterLabel/discoverLetterText" \
                                   "/discoveredLetterText/discoveredLetterTitle/instantlyPermanentLabel/letter/adjective" \
                                   "/labelFemalePlural/successfullyRemovedHediffMessage/offMessage/ingestReportStringEat" \
                                   "/renounceTitleMessage/royalFavorLabel/letterTitle".split('/')
            self.exportType = IntVar(value=0)
            self.collisionOption = IntVar(value=0)

        configs = f"""Alpha's Extractor Configure file
DO NOT EDIT THIS FILE MANUALLY
Config version [int]
{CONFIG_VERSION}
Game directory [string]
{self.gameDir.get()}
Mod directory [string]
{self.modDir.get()}
Excluded tags [string, split with '/']
{'/'.join(self.definedExcludes)}
Included tags [string, split with '/']
{'/'.join(self.definedIncludes)}
Export type [int, 0:xml(plain text), 1:xml(annotated text + "TODO"), 2:xlsx(RimWaldo_format)]
{self.exportType.get()}
Option file collision  [int, 0:Stop, 1:Overwrite, 2:Merge, 3:Refer]
{self.collisionOption.get()}"""

        with open(fileName, 'w', encoding='UTF8') as fin:
            fin.write(configs)


# noinspection PyUnusedLocal
class EntryHint(Entry):
    def __init__(self, master=None, hint="", color='grey', **kwargs):
        super().__init__(master, **kwargs)

        self.hint = hint
        self.hint_color = color
        self.default_color = self['fg']

        self.bind("<FocusIn>", self.foc_in)
        self.bind("<FocusOut>", self.foc_out)

        self.put_hint()

    def put_hint(self):
        self.insert(0, self.hint)
        self['fg'] = self.hint_color

    def foc_in(self, *args):
        if self['fg'] == self.hint_color:
            self.delete('0', 'end')
            self['fg'] = self.default_color

    def get(self):
        tmp = super().get()
        if tmp == self.hint:
            return ""
        else:
            return tmp

    def foc_out(self, *args):
        if not self.get():
            self.put_hint()


# noinspection PyUnusedLocal
class CreateToolTip(object):
    def __init__(self, widget, text='widget info'):
        self.waitTime = 500
        self.wrapLength = 180
        self.widget = widget
        self.text = text
        self.widget.bind("<Enter>", self.enter)
        self.widget.bind("<Leave>", self.leave)
        self.widget.bind("<ButtonPress>", self.leave)
        self.id = None
        self.tw = None

    def enter(self, event=None):
        self.schedule()

    def leave(self, event=None):
        self.unschedule()
        self.hidetip()

    def schedule(self):
        self.unschedule()
        self.id = self.widget.after(self.waitTime, self.showtip)

    def unschedule(self):
        tmp = self.id
        self.id = None
        if tmp:
            self.widget.after_cancel(tmp)

    def showtip(self, event=None):
        x = y = 0
        x, y, cx, cy = self.widget.bbox("insert")
        x += self.widget.winfo_rootx() + 25
        y += self.widget.winfo_rooty() + 20
        self.tw = Toplevel(self.widget)
        self.tw.wm_overrideredirect(True)
        self.tw.wm_geometry("+%d+%d" % (x, y))
        label = Label(self.tw, text=self.text, justify='left',
                      background="#ffffff", relief='solid', borderwidth=1,
                      wraplength=self.wrapLength)
        label.pack(ipadx=1)

    def hidetip(self):
        tw = self.tw
        self.tw = None
        if tw:
            tw.destroy()


def resource_path(relative_path):
    try:
        # noinspection PyUnresolvedReferences,PyProtectedMember
        base_path = sys._MEIPASS
    except AttributeError:
        base_path = os.path.abspath(".")

    return os.path.join(base_path, relative_path)


def convertXML2XLSX(dirname):
    if dirname or dirname == "":
        messagebox.showinfo("미지원", "현재 지원하지 않는 기능입니다.")
        return

    with open(dirname, "rb") as f:
        ioFile = io.BytesIO(f.read())
    ws = load_workbook(ioFile, read_only=True).active
    xmlDict = {}
    for className, nodeName, _, translation in ws.iter_rows(min_row=2, min_col=2, max_col=5, values_only=True):
        if translation:
            if className not in xmlDict:
                xmlDict[className] = {nodeName: translation}
            else:
                xmlDict[className][nodeName] = translation

    for className, nodeDict in xmlDict.items():
        saveDir = '/'.join(dirname.split('/')[:-1]) + f'/Languages/{LANGUAGE}/DefInjected/{className}'
        Path(saveDir).mkdir(parents=True, exist_ok=True)
        with open(f"{saveDir}/{dirname.split('/')[-1].split('.')[0] + '.xml'}", 'w', encoding='UTF8') as fout:
            fout.write("""<?xml version="1.0" encoding="utf-8"?>\n<LanguageData>\n""")
            for nodeName, translation in nodeDict.items():
                fout.write(f'  <{nodeName}>{translation}</{nodeName}>\n')
            fout.write("</LanguageData>")

    messagebox.showinfo("작업 완료", "XML 변환이 완료되었습니다.")


def convertXLSX2XML(filename):
    with open(filename, "rb") as f:
        ioFile = io.BytesIO(f.read())
    ws = load_workbook(ioFile, read_only=True).active
    xmlDict = {}
    for className, nodeName, _, translation in ws.iter_rows(min_row=2, min_col=2, max_col=5, values_only=True):
        if translation:
            if className not in xmlDict:
                xmlDict[className] = {nodeName: translation}
            else:
                xmlDict[className][nodeName] = translation

    for className, nodeDict in xmlDict.items():
        saveDir = '/'.join(filename.split('/')[:-1]) + f'/Languages/{LANGUAGE}/DefInjected/{className}'
        Path(saveDir).mkdir(parents=True, exist_ok=True)
        with open(f"{saveDir}/{filename.split('/')[-1].split('.')[0] + '.xml'}", 'w', encoding='UTF8') as fout:
            fout.write("""<?xml version="1.0" encoding="utf-8"?>\n<LanguageData>\n""")
            for nodeName, translation in nodeDict.items():
                fout.write(f'  <{nodeName}>{translation}</{nodeName}>\n')
            fout.write("</LanguageData>")

    messagebox.showinfo("작업 완료", "XML 변환이 완료되었습니다.")


def loadSelectLocations(window):
    frame = Toplevel(window)
    frame.geometry("800x400+100+100")
    frame.iconbitmap(resource_path('icon.ico'))

    def onDestroy():
        Config.write()
        updateText()
        window.deiconify()
        frame.destroy()

    frame.protocol("WM_DELETE_WINDOW", onDestroy)

    for i in range(4):
        Grid.rowconfigure(frame, i, weight=1)
    Grid.columnconfigure(frame, 1, weight=1)

    labelText = f"""림월드가 설치된 폴더와 림월드 창작마당 폴더를 선택해 주십시오.
한 곳의 경로만 선택해도 됩니다.

선택한 림월드 게임 폴더에는 림월드 실행 파일(RimWorldWin64.exe)이 존재해야 합니다.
기본값: [C:/Program Files (x86)/Steam/steamapps/common/RimWorld]

선택한 창작마당 폴더에는 모드 폴더들이 존재해야 합니다.
기본값: [C:/Program Files (x86)/Steam/steamapps/workshop/content/294100]"""

    label = Label(frame, text=labelText)
    label.grid(row=0, column=0, columnspan=4, sticky='NSWE')

    def onClick1():
        if text := filedialog.askdirectory():
            Config.gameDir.set(text)

    def onClick2():
        if text := filedialog.askdirectory():
            Config.modDir.set(text)

    label1 = Label(frame, text="림월드 게임")
    label1.grid(row=1, column=0, sticky='EW', padx=5)
    entry1 = Entry(frame, textvariable=Config.gameDir)
    entry1.grid(row=1, column=1, columnspan=2, sticky='EW')
    btn1 = Button(frame, text="폴더 선택", command=onClick1)
    btn1.grid(row=1, column=3, padx=5)

    label2 = Label(frame, text="창작마당")
    label2.grid(row=2, column=0, sticky='EW', padx=5)
    entry2 = Entry(frame, textvariable=Config.modDir)
    entry2.grid(row=2, column=1, columnspan=2, sticky='EW')
    btn2 = Button(frame, text="폴더 선택", command=onClick2)
    btn2.grid(row=2, column=3, padx=5)

    btn = Button(frame, text="뒤로가기", command=onDestroy)
    btn.grid(row=3, column=0, columnspan=4, sticky='NS', padx=5, pady=5)


def loadSelectMod(window):
    frame = Toplevel(window)
    frame.geometry("800x400+100+100")
    frame.iconbitmap(resource_path('icon.ico'))

    def onDestroy():
        window.deiconify()
        frame.destroy()

    frame.protocol("WM_DELETE_WINDOW", onDestroy)

    Grid.rowconfigure(frame, 1, weight=1)
    Grid.columnconfigure(frame, 0, weight=2)
    Grid.columnconfigure(frame, 1, weight=1)

    textLabel1 = Label(frame, text="추출할 모드를 선택하세요")
    textLabel1.grid(row=0, column=0, sticky='NSWE', padx=5, pady=5)

    modListBoxValue = StringVar()
    modListBox = Listbox(frame, selectborderwidth=3, listvariable=modListBoxValue,
                         font=font.Font(family="Courier", size=10))
    modListBox.grid(row=1, column=0, sticky='NSWE')

    searchMod = EntryHint(frame, "[모드 검색]", justify='center')
    searchMod.grid(row=2, column=0, sticky='EW', padx=5, pady=5)

    textLabel2 = Label(frame, text="추출할 버전 및 폴더들을 선택하세요")
    textLabel2.grid(row=0, column=1, sticky='NSWE', padx=5, pady=5)

    dirList = StringVar()
    dirListBox = Listbox(frame, selectmode='multiple', selectborderwidth=10, listvariable=dirList)
    dirListBox.grid(row=1, column=1, sticky='NSWE')

    extractButton = Button(frame, text="선택한 폴더의 노드 추출")
    extractButton.grid(row=2, column=1)

    corePathList = [p.replace('\\', '/') for p in glob.glob(Config.gameDir.get() + '/Data/*') if os.path.isdir(p)]
    manualModPathList = [p.replace('\\', '/') for p in glob.glob(Config.gameDir.get() + '/Mods/*') if os.path.isdir(p)]
    workshopModPathList = [p.replace('\\', '/') for p in glob.glob(Config.modDir.get() + '/*') if os.path.isdir(p)]

    if not (corePathList + manualModPathList + workshopModPathList):  # If No Mod
        messagebox.showerror("모드 폴더 찾을 수 없음", "선택한 폴더에 어떤 하위 폴더도 존재하지 않습니다.\n프로그램을 종료합니다.")
        exit(0)

    modsNameDict = {}
    sep = ' | '
    for modPath in corePathList:
        modsNameDict[f"    CORE   {sep}{modPath.split('/')[-1]}"] = modPath, f"{modPath.split('/')[-1]}"
    for modPath in manualModPathList + workshopModPathList:
        code = " ??????????"
        try:
            code = f"{int(modPath.split('/')[-1]):11d}"
        except (FileNotFoundError, ValueError):
            pass
        try:
            with open(modPath + '/About/PublishedFileId.txt') as fin:
                code = f"{int(fin.read().replace(WORD_NEWLINE, '')):11d}"
        except (FileNotFoundError, ValueError):
            pass
        try:
            name = et.parse(modPath + '/About/About.xml').getroot().find('name').text
        except (FileNotFoundError, ValueError, AttributeError):
            name = modPath.split('/')[-1]
        modsNameDict[f"{code}{sep}{name}"] = modPath, f"{name} - {code.replace(' ', '')}"
    modsNameDictKeys = list(modsNameDict.keys())
    modsNameDictKeys.sort(key=lambda x: x.split(sep)[1])
    modListBoxValue.set(modsNameDictKeys)

    extractableDirPathList = []
    extractableDirNameList = []

    modName = ""

    def onModSelect(evt):
        try:
            nonlocal modName
            modPath, modName = modsNameDict[evt.widget.get(int(evt.widget.curselection()[0]))]
        except IndexError:
            return

        extractableDirPathList.clear()
        extractableDirNameList.clear()
        autoSelectIndices = []
        try:
            modVersionNodeList = list(et.parse(f'{modPath}/LoadFolders.xml').getroot())
            for eachVersionNode in modVersionNodeList:
                for eachLoad in list(eachVersionNode):
                    if not eachLoad.text:
                        continue
                    path = os.path.join(modPath, eachLoad.text) if eachLoad.text != '/' else modPath
                    try:
                        attr = eachLoad.attrib['IfModActive']
                    except KeyError:
                        attr = ""
                    for eachType in os.listdir(path):
                        if eachType in EXTRACTABLE_DIRS:
                            extractableDirPathList.append(os.path.join(path, eachType))
                            if eachType == "Languages":
                                eachType = "Keyed/Strings"
                            name = f"{eachVersionNode.tag} - {eachType}"
                            if attr:
                                name = f"{name} [모드 의존성: {attr}]"
                            extractableDirNameList.append(name)
                            if RIMWORLD_VERSION in eachVersionNode.tag or 'default' in eachVersionNode.tag:
                                autoSelectIndices.append(len(extractableDirNameList) - 1)

        except FileNotFoundError:
            for eachLoad in [modPath] + glob.glob(f"{modPath}/*"):
                if os.path.isdir(eachLoad):
                    for eachType in os.listdir(eachLoad):
                        if eachType in EXTRACTABLE_DIRS:
                            extractableDirPathList.append(os.path.join(eachLoad, eachType))
                            ver = eachLoad.split('\\')[-1] if eachLoad != modPath else "default"
                            if eachType == "Languages":
                                eachType = "Keyed/Strings"
                            extractableDirNameList.append(f"{ver} - {eachType}")
                            if RIMWORLD_VERSION in ver or 'default' in ver:
                                autoSelectIndices.append(len(extractableDirNameList) - 1)

        dirList.set(extractableDirNameList)
        for i in autoSelectIndices:
            dirListBox.selection_set(i)

    modListBox.bind('<<ListboxSelect>>', onModSelect)

    def onExtract():
        if dict_class or dict_keyed or list_strings:
            if messagebox.askyesno("추출 노드 초기화",
                                   "본 프로그램에서 추출된 기존 노드가 존재합니다. 계속 진행할 경우 추출된 기존 노드와 분류 작업이 폐기되고 " +
                                   "현재 선택된 모드의 노드가 새로 추출됩니다. 정말 진행할까요?"):
                dict_class.clear()
                dict_keyed.clear()
                list_strings.clear()
            else:
                return

        Config.extractPathList = [extractableDirPathList[idx] for idx in dirListBox.curselection()]
        if not Config.extractPathList:
            messagebox.showerror("폴더를 선택하세요", "추출할 폴더를 하나 이상 선택하세요.")
            return
        Config.modName = modName
        Config.exportDirName.set("".join(filter(lambda ch: ch not in "\\/:*?\"<>|", modName)))
        Config.exportFileName.set("".join(filter(lambda ch: ch not in "\\/:*?\"<>|", modName)))
        updateText()
        window.deiconify()
        frame.destroy()

        for extractPath in Config.extractPathList:
            if extractPath.split('\\')[-1] == 'Defs':
                GoExtractLists = glob.glob(extractPath + "/**/*.xml", recursive=True)
                for path in GoExtractLists:
                    try:
                        extracts = extractDefs(et.parse(path).getroot())
                    except ValueError as e:
                        messagebox.showerror("에러 발생", str(e) + "\n파일명: " + path)
                        return

                    for className, lastTag, tag, text in extracts:
                        if className == 'ScenarioDef':
                            if tag != lastTag and (tags := tag.split('.'))[1] != 'scenario':
                                tags.insert(1, 'scenario')
                                if className in dict_class and (tags := '.'.join(tags)) not in dict_class[className]:
                                    dict_class[className] = {tags: (lastTag, text)}
                        if className in dict_class:
                            dict_class[className][tag] = (lastTag, text)
                        else:
                            dict_class[className] = {tag: (lastTag, text)}
                        if lastTag in Config.dict_tags_text:
                            Config.dict_tags_text[lastTag].append(text)
                        else:
                            Config.dict_tags_text[lastTag] = [text]

            elif extractPath.split('\\')[-1] == 'Languages':
                GoExtractLists = glob.glob(extractPath + "\\English\\Keyed\\**\\*.xml", recursive=True)
                for path in GoExtractLists:
                    try:
                        nodes = list(et.parse(path).getroot())
                    except ValueError as e:
                        messagebox.showerror("에러 발생", str(e) + "\n파일명: " + path)
                        return
                    for node in nodes:
                        dict_keyed[node.tag] = node.text if node.text else ""
                Config.list_strings = glob.glob(extractPath + "\\English\\Strings\\**\\*.txt", recursive=True)

            elif extractPath.split('\\')[-1] == 'Patches':
                GoExtractLists = glob.glob(extractPath + "/**/*.xml", recursive=True)
                for path in GoExtractLists:
                    try:
                        extracts = extractPatches(et.parse(path).getroot())
                    except ValueError as e:
                        messagebox.showerror("에러 발생", str(e) + "\n파일명: " + path)
                        return
                    for extract in extracts:
                        if extract:
                            className, lastTag, tag, text = extract
                        else:
                            continue
                        if className == 'ScenarioDef':
                            if tag != lastTag and (tags := tag.split('.'))[1] != 'scenario':
                                tags.insert(1, 'scenario')
                                if className in dict_class and (tags := '.'.join(tags)) not in dict_class[className]:
                                    dict_class[className] = {tags: (lastTag, text)}
                        if className in dict_class:
                            dict_class[className][tag] = (lastTag, text)
                        else:
                            dict_class[className] = {tag: (lastTag, text)}
                        if lastTag in Config.dict_tags_text:
                            Config.dict_tags_text[lastTag].append(text)
                        else:
                            Config.dict_tags_text[lastTag] = [text]
            else:
                messagebox.showerror("에러 발생", "Defs, Patches, Keyed, Strings 이외의 폴더는 아직 추출할 수 없습니다.\n자동으로 제외합니다.")

        Config.excludes = []
        Config.defaults = sorted(Config.dict_tags_text.keys())
        Config.includes = []

        while True:
            candidate = Config.defaults.pop(0)
            try:
                int(candidate)
                Config.excludes.append(candidate)
            except ValueError:
                Config.defaults.insert(0, candidate)
                break

        for _ in range(len(Config.defaults)):
            candidate = Config.defaults.pop(0)
            if candidate in Config.definedExcludes:
                Config.excludes.append(candidate)
            elif candidate in Config.definedIncludes:
                Config.includes.append(candidate)
            else:
                Config.defaults.append(candidate)

    extractButton.configure(command=onExtract)

    # noinspection PyUnusedLocal
    def onSearch(evt):
        modSearch = searchMod.get().lower().replace(' ', '')

        if modSearch != "":
            modShow = [modName for modName in modsNameDictKeys if modSearch in modName.lower().replace(' ', '')]
        else:
            modShow = modsNameDictKeys

        modShow.sort(key=lambda x: x.split(sep)[1])
        modListBoxValue.set(modShow)

    searchMod.bind("<KeyRelease>", onSearch)


def parse_recursive(parent, className, tag, lastTag=None, unKnownLiNo=False):
    if list(parent):
        num_list = 0
        for child in list(parent):
            if child.tag == 'li':
                if 'TKey' in child.attrib:
                    yield from parse_recursive(child, className, tag + '.' + child.attrib['TKey'], lastTag)
                elif unKnownLiNo:
                    yield from parse_recursive(child, className, tag + '.???', lastTag)
                else:
                    yield from parse_recursive(child, className, tag + '.' + str(num_list), lastTag)
                num_list += 1
            else:
                yield from parse_recursive(child, className, tag + '.' + child.tag, child.tag)
    elif parent.text and parent.text.replace('\n', '').replace(' ', ''):
        yield className, lastTag, tag, (parent.text.replace('&', '&amp;').replace('<', '&lt;') if parent.text else "")


def extractDefs(root):
    if 'value' != root.tag and 'Defs' != root.tag:
        raise ValueError("첫 태그가 Defs가 아닙니다. 오류를 발생시킨 모드 이름을 Alpha에게 제보해주세요.")

    for item in list(root):
        try:
            parentDefs[item.attrib['Name']] = item
        except KeyError:
            pass
        try:
            if item.attrib['Abstract'].lower() == 'true':
                continue
        except KeyError:
            pass

        try:
            defName = item.find('defName').text
        except AttributeError:
            continue

        className = item.tag
        if className == 'Def':
            if 'Class' in item.attrib:
                className = item.attrib['Class']
            else:
                raise ValueError("Def임에도 불구하고 클래스 이름이 없습니다. 오류를 발생시킨 모드 이름과 파일명을 Alpha에게 제보해주세요.")

        if 'ParentName' in item.attrib and item.attrib['ParentName'] in parentDefs:
            yield from parse_recursive(parentDefs[item.attrib['ParentName']], className, defName)

        yield from parse_recursive(item, className, defName)


def xpathAnalysis(xpath):
    className = ""
    if '..' in xpath:
        return False, 1
    if '(' in xpath:
        return False, 2
    defNameIndex = -1
    xpath = xpath.split('/')
    for i in range(len(xpath)):
        if '[' in xpath[i]:
            if 'defName' in xpath[i]:
                defNameIndex = i
                className, xpath[i] = xpath[i].split('[')
                xpath[i] = xpath[i].split(']')[0]
                if '!=' in xpath[i] or xpath[i].count('=') > 1:
                    return False, 3
                isThereDefName = False
                defName = None
                for elem in xpath[i].split('='):
                    if elem.replace(' ', '') == 'defName':
                        isThereDefName = True
                    else:
                        defName = eval(elem)
                if not isThereDefName or not defName:
                    return False, 4
                xpath[i] = defName
            elif 'li' in xpath[i]:
                xpath[i] = xpath[i].split('[')[1].split(']')[0]
                if '!=' in xpath[i] or xpath[i].count('=') > 1:
                    return False, 5
                for elem in xpath[i].split('='):
                    if '\"' in elem or '\'' in elem:
                        xpath[i] = eval(elem)
            elif defNameIndex != -1:
                return False, 6
    if defNameIndex == -1:
        return False, 7
    if not className:
        return False, -1
    return className, xpath[defNameIndex:]


def analysisOperation(node, modDepend):
    if (operation := node.attrib['Class']) == 'PatchOperationFindMod':
        modDepend.extend([li.text for li in list(node.find('mods'))])
        try:
            yield from analysisOperation(node.find('match'), modDepend)
        except AttributeError:
            yield from analysisOperation(node.find('nomatch'), modDepend)
    elif operation == 'PatchOperationSequence':
        for li in list(node.find('operations')):
            yield from analysisOperation(li, modDepend)
    elif operation == 'PatchOperationInsert':
        try:
            xpath = node.find('xpath').text
            className, tagList = xpathAnalysis(xpath)
            if not className:
                print(f'다음 xpath는 {tagList}번 사유로 파싱할 수 없음: {xpath}')
                return
            yield from parse_recursive(node.find('value'), className, '.'.join(tagList[:-1]), lastTag=tagList[-2],
                                       unKnownLiNo=True)
        except Exception as e:
            print(e)
            return
    elif operation in ['PatchOperationAdd', 'PatchOperationReplace']:
        if operation == 'PatchOperationReplace' and modDepend:
            try:
                xpath = node.find('xpath').text
                print('모드 의존성과 함께 노드를 변경하는 패치는 추출하지 않음, xpath:', xpath)
            except AttributeError:
                print('모드 의존성과 함께 노드를 변경하는 패치는 추출하지 않음, xpath 존재하지 않음')
                return
        try:
            xpath = node.find('xpath').text
            if xpath.replace('/', '') == 'Defs':
                yield from extractDefs(node.find('value'))
            className, tagList = xpathAnalysis(xpath)
            if not className:
                print(f'다음 xpath는 {tagList}번 사유로 파싱할 수 없음: {xpath}')
                return
            yield from parse_recursive(node.find('value'), className, '.'.join(tagList), lastTag=tagList[-1])
        except Exception as e:
            print(e)
            return
    elif operation == 'PatchOperationRemove':
        try:
            xpath = node.find('xpath').text
            print('노드를 제거하는 패치는 추출하지 않음, xpath:', xpath)
        except AttributeError:
            print('노드를 제거하는 패치는 추출하지 않음, xpath 존재하지 않음')
            return
    else:
        return


def extractPatches(root):
    assert 'Patch' == root.tag, "첫 태그가 Patch가 아닙니다. 오류를 발생시킨 모드 이름을 Alpha에게 제보해주세요."

    for item in list(root):
        assert 'Operation' == item.tag, "Patch 하위 태그가 Operation이 아닙니다. 오류를 발생시킨 모드 이름을 Alpha에게 제보해주세요."
        yield from analysisOperation(item, [])


def loadSelectTags(window):
    frame = Toplevel(window)
    frame.geometry("800x400+100+100")
    frame.iconbitmap(resource_path('icon.ico'))

    def onDestroy():
        window.deiconify()
        frame.destroy()

    frame.protocol("WM_DELETE_WINDOW", onDestroy)

    if not Config.dict_tags_text:
        if dict_keyed or list_strings:
            messagebox.showerror("노드 없음",
                                 "추출 가능한 Defs/Patches의 xml이 존재하지 않지만, Keyed/Strings가 존재하므로 노드 분류를 필요로 하지 않습니다. 본 단계를 생략해 주십시오.")
        else:
            messagebox.showerror("에러 발생", "추출 가능한 xml가 존재하지 않거나, 찾을 수 없습니다.\n모드 선택부터 다시 시도해 주십시오.")
        onDestroy()
        return

    Grid.rowconfigure(frame, 0, weight=1)  # label
    Grid.rowconfigure(frame, 1, weight=9)  # list
    Grid.rowconfigure(frame, 2, weight=1)  # moveButton
    Grid.rowconfigure(frame, 3, weight=1)  # search
    Grid.rowconfigure(frame, 4, weight=1)  # extract
    for i in range(3):
        Grid.columnconfigure(frame, i, weight=1)

    def showTexts(evt):
        w = evt.widget
        tag = w.get(int(w.curselection()[0]))
        dialog = Toplevel(window)
        dialog.title(tag)
        text = Text(dialog)
        text.insert(1.0, '\n'.join(sorted(list(set(Config.dict_tags_text[tag])))))
        text.configure(state='disabled')
        text.bind("<Escape>", lambda x: dialog.destroy())
        text.bind("<q>", lambda x: moveTag(tag, 0, dialog=dialog))
        text.bind("<w>", lambda x: moveTag(tag, 1, dialog=dialog))
        text.bind("<e>", lambda x: moveTag(tag, 2, dialog=dialog))
        text.focus_set()
        Grid.rowconfigure(dialog, 0, weight=1)
        Grid.columnconfigure(dialog, 0, weight=1)
        text.grid(row=0, column=0, sticky='NSWE')

    Label(frame, text="추출 제외 태그").grid(row=0, column=0, sticky='NSWE')
    excludeVar = StringVar(value=Config.excludes)
    excludeList = Listbox(frame, listvariable=excludeVar)
    excludeList.grid(row=1, column=0, sticky='NSWE')
    excludeList.bind("<w>", lambda x: moveTag(excludeList.get(excludeList.curselection()[0]), 1))
    excludeList.bind("<e>", lambda x: moveTag(excludeList.get(excludeList.curselection()[0]), 2))

    Label(frame, text="미분류 태그\n(추출 제외)").grid(row=0, column=1, sticky='NSWE')
    defaultVar = StringVar(value=Config.defaults)
    defaultList = Listbox(frame, listvariable=defaultVar)
    defaultList.grid(row=1, column=1, sticky='NSWE')
    defaultList.bind("<q>", lambda x: moveTag(defaultList.get(defaultList.curselection()[0]), 0))
    defaultList.bind("<e>", lambda x: moveTag(defaultList.get(defaultList.curselection()[0]), 2))

    Label(frame, text="추출 대상 태그").grid(row=0, column=2, sticky='NSWE')
    includeVar = StringVar(value=Config.includes)
    includeList = Listbox(frame, listvariable=includeVar)
    includeList.grid(row=1, column=2, sticky='NSWE')
    includeList.bind("<q>", lambda x: moveTag(includeList.get(includeList.curselection()[0]), 0))
    includeList.bind("<w>", lambda x: moveTag(includeList.get(includeList.curselection()[0]), 1))

    def moveTag(tag, destination, dialog=None):
        if dialog:
            dialog.destroy()
        try:
            toMove = Config.defaults.pop(Config.defaults.index(tag))
            if destination == 1:
                return
            if defaultList.get('end') == toMove:
                defaultList.activate(defaultList.size() - 2)
                defaultList.selection_set(defaultList.size() - 2)
        except ValueError:
            try:
                toMove = Config.excludes.pop(Config.excludes.index(tag))
                if destination == 0:
                    return
                if excludeList.get('end') == toMove:
                    excludeList.activate(excludeList.size() - 2)
                    excludeList.selection_set(excludeList.size() - 2)
            except ValueError:
                try:
                    toMove = Config.includes.pop(Config.includes.index(tag))
                    if destination == 2:
                        return
                    if includeList.get('end') == toMove:
                        includeList.activate(includeList.size() - 2)
                        includeList.selection_set(includeList.size() - 2)
                except ValueError:
                    return

        [Config.excludes, Config.defaults, Config.includes][destination].append(toMove)

        excludeVar.set(sorted(Config.excludes))
        defaultVar.set(sorted(Config.defaults))
        includeVar.set(sorted(Config.includes))

        if destination == 0:
            for i, v in enumerate(excludeList.get(0, 'end')):
                if v == toMove:
                    excludeList.see(i)
                    break
        elif destination == 0:
            for i, v in enumerate(defaultList.get(0, 'end')):
                if v == toMove:
                    defaultList.see(i)
                    break
        elif destination == 0:
            for i, v in enumerate(includeList.get(0, 'end')):
                if v == toMove:
                    includeList.see(i)
                    break

    excludeList.bind('<Double-Button-1>', showTexts)
    defaultList.bind('<Double-Button-1>', showTexts)
    includeList.bind('<Double-Button-1>', showTexts)

    Label(frame, text="[Q]를 입력해 추출 제외").grid(row=2, column=0)
    Label(frame, text="[W]를 입력해 분류 취소").grid(row=2, column=1)
    Label(frame, text="[E]를 입력해 추출 추가").grid(row=2, column=2)

    searchTag = EntryHint(frame, "[태그 필터]")
    searchTag.grid(row=3, column=0, sticky='EW')
    searchText = EntryHint(frame, "[원본 텍스트 필터]")
    searchText.grid(row=3, column=1, columnspan=2, sticky='EW')

    dictTextTag = {}
    for tag, texts in Config.dict_tags_text.items():
        for text in texts:
            try:
                dictTextTag[text].append(tag)
            except KeyError:
                dictTextTag[text] = [tag]

    # noinspection PyUnusedLocal
    def onSearch(evt):
        tagSearch = searchTag.get().lower().replace(' ', '')
        tagFlag = (tagSearch != "")
        textSearch = searchText.get().lower().replace(' ', '')
        textFlag = (textSearch != "")

        Config.excludes = Config.excludes + Config.excludeHide
        Config.defaults = Config.defaults + Config.defaultHide
        Config.includes = Config.includes + Config.includeHide

        filteredTags = []
        if textFlag:
            for tags in [dictTextTag[text] for text in dictTextTag.keys() if
                         textSearch in text.lower().replace(' ', '')]:
                filteredTags.extend(tags)
            if tagFlag:
                filteredTags = [tag for tag in list(set(filteredTags)) if tagSearch in tag.lower().replace(' ', '')]
        elif tagFlag:
            filteredTags = [tag for tag in Config.dict_tags_text.keys() if tagSearch in tag.lower().replace(' ', '')]

        if textFlag or tagFlag:
            excludeIntersect = list(set(Config.excludes) & set(filteredTags))
            Config.excludeHide = [tag for tag in Config.excludes if tag not in excludeIntersect]
            Config.excludes = excludeIntersect
            defaultIntersect = list(set(Config.defaults) & set(filteredTags))
            Config.defaultHide = [tag for tag in Config.defaults if tag not in defaultIntersect]
            Config.defaults = defaultIntersect
            includeIntersect = list(set(Config.includes) & set(filteredTags))
            Config.includeHide = [tag for tag in Config.includes if tag not in includeIntersect]
            Config.includes = includeIntersect
        else:
            excludeHide = []
            defaultHide = []
            includeHide = []

        excludeVar.set(sorted(Config.excludes))
        defaultVar.set(sorted(Config.defaults))
        includeVar.set(sorted(Config.includes))

    searchTag.bind("<KeyRelease>", onSearch)
    searchText.bind("<KeyRelease>", onSearch)

    Button(frame, text="뒤로가기", command=onDestroy).grid(row=4, column=1, sticky='NSWE', padx=2, pady=2)

    def loadTagList():
        if not messagebox.askyesno("태그 분류 불러오기",
                                   "사용자가 사전에 분류했던 태그 분류 작업을 적용합니다.\n" +
                                   "기존 분류 작업의 내용은 보존되지 않으며, 불러온 분류 파일로 덮어씌워집니다. 정말 진행할까요?"):
            return
        fileName = filedialog.askopenfilename(title="불러오기", filetypes=[("태그 분류 작업 파일", "*.tag")])
        if fileName == "":
            return
        try:
            with open(fileName, 'r') as fin:
                reads = fin.read().split('\n')

            customExcludes = reads[1].split('/')
            customIncludes = reads[3].split('/')

            Config.defaults = Config.excludes + Config.defaults + Config.includes
            Config.excludes = []
            Config.includes = []

            for _ in range(len(Config.defaults)):
                candidate = Config.defaults.pop(0)
                if candidate in customExcludes:
                    Config.excludes.append(candidate)
                elif candidate in customIncludes:
                    Config.includes.append(candidate)
                else:
                    Config.defaults.append(candidate)

            excludeVar.set(sorted(Config.excludes))
            defaultVar.set(sorted(Config.defaults))
            includeVar.set(sorted(Config.includes))
            messagebox.showinfo("불러오기 완료", "태그 분류를 성공적으로 불러왔습니다. 기존 작업은 버려졌습니다.")
        except FileNotFoundError:
            messagebox.showerror("파일을 열 수 없습니다.", "파일을 여는 중 오류가 발생했습니다.\n파일이 삭제되었거나 이동되었을 수 있습니다.")
            return
        except IndexError:
            messagebox.showerror("분류 파일 불러오기 실패", "분류 파일을 불러오는 데 실패하였습니다.\n분류 파일의 형식이 잘못되었을 수 있습니다.")
            return

    def saveTagList():
        fileName = filedialog.asksaveasfilename(title="저장", filetypes=[("태그 분류 작업 파일", "*.tag")])
        if fileName == "":
            messagebox.showerror("저장 취소", "저장을 취소하였습니다.")
            return
        if fileName[-4:].lower() != '.tag':
            fileName += '.tag'
        writings = '\n'.join(
            ("Excludes tag list, split with [/], spacing ignored, case sensitive", '/'.join(Config.excludes),
             "Includes tag list, split with [/], spacing ignored, case sensitive", '/'.join(Config.includes)))
        with open(fileName, 'w') as fin:
            fin.write(writings)
        messagebox.showinfo("저장하기 완료", "태그 분류를 성공적으로 저장했습니다.")

    save = Button(frame, command=saveTagList, text="태그 분류 저장하기")
    load = Button(frame, command=loadTagList, text="태그 분류 불러오기")
    save.grid(row=4, column=0)
    load.grid(row=4, column=2)


def loadSelectExport(window):
    frame = Toplevel(window)
    frame.geometry("800x400+100+100")
    frame.iconbitmap(resource_path('icon.ico'))

    def onDestroy():
        Config.write()
        updateText()
        window.deiconify()
        frame.destroy()

    frame.protocol("WM_DELETE_WINDOW", onDestroy)

    for i in range(8):
        Grid.rowconfigure(frame, i, weight=1)
    for i in range(1):
        Grid.columnconfigure(frame, i, weight=1)

    Label(frame, text="결과를 저장할 폴더의 이름을 지정하세요").grid(row=0, column=0)
    Entry(frame, textvariable=Config.exportDirName, justify='center').grid(row=1, column=0, sticky='EW')

    Label(frame, text="결과 파일의 이름을 지정하세요 (.xml / .xlsx와 같은 확장자를 붙일 필요는 없습니다.)").grid(row=2, column=0)
    Entry(frame, textvariable=Config.exportFileName, justify='center').grid(row=3, column=0, sticky='EW')

    Label(frame, text="추출한 노드의 출력 방식 지정").grid(row=4, column=0)
    row5Frame = Frame(frame)
    row5Frame.grid(row=5, column=0)
    Radiobutton(row5Frame, text="xml [원문]", value=EXPORT_XML_PLAIN, variable=Config.exportType).grid(row=0, column=0)
    Radiobutton(row5Frame, text="xml [원문 주석 + TODO]", value=EXPORT_XML_ANNOTATION, variable=Config.exportType).grid(
        row=0, column=1)
    Radiobutton(row5Frame, text="xlsx [림왈도 서식]", value=EXPORT_XLSX, variable=Config.exportType).grid(row=0, column=2)

    Label(frame, text="결과 폴더와 파일명이 일치할 경우 파일의 작업 방법").grid(row=6, column=0)
    row7Frame = Frame(frame)
    row7Frame.grid(row=7, column=0)
    btnTexts = ["중단하기", "덮어쓰기", "병합하기", "참조하기"]
    tooltips = ["파일 충돌이 발생할 경우, 파일 출력을 중단하고 알림을 표시합니다. " +
                "이 경우, 파일 충돌이 발생할 때까지 작성된 파일은 남아 있음에 유의하십시오.",
                "파일 충돌이 발생할 경우, 해당 파일을 내용을 삭제하고 새로 작성합니다. " +
                "이 경우, 기존 파일을 복구할 수 없으므로 사전 백업이 권장됩니다.",
                "파일 충돌이 발생할 경우, 해당 파일에 새로운 태그들을 추가해 병합합니다. " +
                "추출기가 추출하지 않았지만 존재했던 내용은 파일의 하단에 출력됩니다. xlsx 출력 모드에서는 참조하기로 적용됩니다.",
                "파일 충돌이 발생할 경우, 해당 파일의 내용을 새로 작성하되, 기존 파일에 같은 태그가 있을 경우 해당 내용을 보존합니다. " +
                "추출기가 추출하지 않았지만 존재했던 내용은 버려집니다."]
    for i, (text, tooltip) in enumerate(zip(btnTexts, tooltips)):
        tmp = Radiobutton(row7Frame, text=text, value=i, variable=Config.collisionOption)
        CreateToolTip(tmp, tooltip)
        tmp.grid(row=0, column=i)

    Button(frame, text="뒤로가기", command=onDestroy).grid(row=8, column=0)


def updateText():
    global mainTextVar
    mainText = f"""림월드, 혹은 림월드 모드의 텍스트를 추출 * 분류 * 출력할 수 있는 알파추출기입니다.

version = {EXTRACTOR_VERSION}

림월드 게임 위치: {Config.gameDir.get()}
창작마당 위치: {Config.modDir.get()}

추출할 코어 혹은 모드: {Config.modName if Config.modName else "지정되지 않음"}

출력 폴더 위치: {Config.exportDirName.get() if Config.exportDirName.get() else "지정되지 않음"}
출력 파일 이름: {Config.exportFileName.get() if Config.exportFileName.get() else "지정되지 않음"}

출력 형식: {"인게임에 바로 적용 가능한 xml 파일" if Config.exportType.get() != 2 else "크라우딘에 업로드 할 수 있는 xlsx 파일"}

파일 충돌 시: {"파일 출력을 중단하고 경고창을 표시함" if Config.collisionOption.get() == 0 else "기존 파일을 삭제하고 덮어씀" if Config.collisionOption.get() == 1 else "기존 파일의 노드와 추출한 노드를 함께 출력" if Config.collisionOption.get() == 2 else "기존 파일의 노드는 번역만 참고하고 추출한 노드만 출력"}

"""

    mainTextVar.set(mainText)


if __name__ == '__main__':

    FRAME_EXIT = -1
    FRAME_MAIN = 0
    FRAME_LOCATION_SELECT = 1
    FRAME_MOD_SELECT = 2
    FRAME_NODE_CLASSIFICATION = 3
    FRAME_EXPORT_OPTION = 4

    parentDefs = {}

    dict_class = {}
    dict_keyed = {}
    list_strings = []

    window = Tk()
    window.title("Alpha의 림월드 모드 언어 추출기")
    window.geometry("800x400+100+100")
    window.iconbitmap(resource_path('icon.ico'))
    Grid.rowconfigure(window, 0, weight=1)
    Grid.columnconfigure(window, 0, weight=1)

    Config = Configures()

    frame = Frame(window)
    frame.grid(row=0, column=0, sticky='NSWE')

    for i in range(6):
        Grid.rowconfigure(frame, i, weight=1)
    for i in range(4):
        Grid.columnconfigure(frame, i, weight=1)

    mainTextVar = StringVar()
    updateText()
    mainLabel = Label(frame, textvariable=mainTextVar)
    mainLabel.grid(row=0, column=0, rowspan=4, columnspan=4, sticky='NSWE')


    def onClick(i):
        window.withdraw()

        if i == FRAME_LOCATION_SELECT:
            loadSelectLocations(window)
        elif i == FRAME_MOD_SELECT:
            loadSelectMod(window)
        elif i == FRAME_NODE_CLASSIFICATION:
            loadSelectTags(window)
        elif i == FRAME_EXPORT_OPTION:
            loadSelectExport(window)
        else:
            pass


    btn1 = Button(frame, text="1. 림월드 위치 지정", command=lambda: onClick(FRAME_LOCATION_SELECT))
    btn1.grid(row=4, column=0, sticky='NSWE', padx=10, pady=5)
    btn2 = Button(frame, text="2. 추출 모드 선택", command=lambda: onClick(FRAME_MOD_SELECT))
    btn2.grid(row=4, column=1, sticky='NSWE', padx=10, pady=5)
    btn3 = Button(frame, text="3. 출력 노드 선택", command=lambda: onClick(FRAME_NODE_CLASSIFICATION))
    btn3.grid(row=4, column=2, sticky='NSWE', padx=10, pady=5)
    btn4 = Button(frame, text="4. 출력 옵션 지정", command=lambda: onClick(FRAME_EXPORT_OPTION))
    btn4.grid(row=4, column=3, sticky='NSWE', padx=10, pady=5)


    def exportXml():
        for ch in "\\/:*?\"<>|":
            if ch in Config.exportFileName.get():
                return [3]
        savedList = []
        for className, tag_dict in dict_class.items():  # Defs / Patches
            isThereNoIncludes = True
            for lastTag, _ in tag_dict.values():  # check existence of include tag
                if lastTag in Config.includes:
                    isThereNoIncludes = False
                    break
            if isThereNoIncludes:
                continue  # pass the class

            filename = Config.exportDirName.get() + f'/Languages/{LANGUAGE}/DefInjected/' + className + '/' + Config.exportFileName.get() + '.xml'
            Path('/'.join(filename.split('/')[:-1])).mkdir(parents=True, exist_ok=True)

            if Config.collisionOption.get() == 0:  # collision -> stop
                try:
                    with open(filename, 'r', encoding='UTF8') as _:
                        return 1, (className, WORD_NEWLINE.join(savedList))
                except FileNotFoundError:
                    pass

            alreadyDefinedDict = {}
            if Config.collisionOption.get() > 1:  # collision -> merge/refer
                try:
                    for node in list(et.parse(filename).getroot()):
                        if list(node):
                            alreadyDefinedDict[node.tag] = [li.text for li in list(node)]
                        elif node.text != "TODO":
                            alreadyDefinedDict[node.tag] = node.text
                except FileNotFoundError:
                    pass

            writingTextList = []
            for tag, (lastTag, text) in tag_dict.items():
                if lastTag in Config.includes:
                    if type(text) == list:
                        try:
                            for i, v in enumerate(alreadyDefinedDict[tag]):
                                if alreadyDefinedDict[tag][i] != "TODO":
                                    text[i] = alreadyDefinedDict[tag][i]
                            del alreadyDefinedDict[tag]
                        except TypeError:
                            pass
                        tmp = [f'    <!-- {text_i} -->{WORD_NEWLINE}    <li>TODO</li>' for text_i in text]
                        writingTextList.append(
                            f"  <{tag}>\n{WORD_NEWLINE.join(tmp)}\n  </{tag}>"
                            if Config.exportType.get() == 1
                            else f"  <{tag}>\n{WORD_NEWLINE.join([f'    <li>{t}</li>' for t in text])}\n  </{tag}>")
                    else:
                        try:
                            writingTextList.append(f"  <!-- {text} -->\n  <{tag}>{alreadyDefinedDict[tag]}</{tag}>"
                                                   if Config.exportType.get() == 1
                                                   else f"  <{tag}>{alreadyDefinedDict[tag]}</{tag}>")
                            del alreadyDefinedDict[tag]
                        except KeyError:
                            writingTextList.append(f"  <!-- {text} -->\n  <{tag}>TODO</{tag}>"
                                                   if Config.exportType.get() == 1
                                                   else f"  <{tag}>{text}</{tag}>")

            with open(filename, 'w', encoding='UTF8') as fin:
                fin.write("""<?xml version="1.0" encoding="utf-8"?>\n<LanguageData>\n""")
                fin.write('\n'.join(writingTextList))
                if Config.collisionOption.get() == 2 and alreadyDefinedDict:  # collision -> merge
                    fin.write("\n\n  <!-- 알파의 추출기는 추출하지 않았지만 이미 존재했던 노드들 \n\n")
                    for tag, text in alreadyDefinedDict.items():
                        if type(text) == list:
                            fin.write(f"  <{tag}>\n")
                            fin.write('\n'.join([f"    <li>{eachText}</li>" for eachText in text]))
                            fin.write(f"\n  </{tag}>\n")
                        else:
                            fin.write(f"  <{tag}>{text}</{tag}>\n")
                    fin.write("  -->")
                fin.write("\n</LanguageData>")

            savedList.append(className)

        # Keyed
        if len(dict_keyed) > 0:
            filename = Config.exportDirName.get() + f'/Languages/{LANGUAGE}/Keyed/' + Config.exportFileName.get() + '.xml'
            Path('/'.join(filename.split('/')[:-1])).mkdir(parents=True, exist_ok=True)

            if Config.collisionOption.get() == 0:  # collision -> stop
                try:
                    with open(filename, 'r', encoding='UTF8') as _:
                        return 1, ("Keyed", WORD_NEWLINE.join(savedList))
                except FileNotFoundError:
                    pass

            alreadyDefinedDict = {}
            if Config.collisionOption.get() > 1:  # collision -> merge/refer
                try:
                    for node in list(et.parse(filename).getroot()):
                        if list(node):
                            messagebox.showerror("기존 번역에서 내부 노드 발견됨",
                                                 "본 프로그램은 Keyed 파일의 텍스트에 하위 노드(<>)가 없는 것으로 가정하였습니다. " +
                                                 "해당 노드의 번역은 보존되지 않았을 수 있습니다.")
                            alreadyDefinedDict[node.tag] = [li.text for li in list(node)]
                        elif node.text != "TODO":
                            alreadyDefinedDict[node.tag] = node.text
                except FileNotFoundError:
                    pass

            writingTextList = []
            for tag, text in dict_keyed.items():
                text = text.replace('<', '&lt;')
                try:
                    writingTextList.append(f"  <!-- {text} -->\n  <{tag}>{alreadyDefinedDict[tag]}</{tag}>"
                                           if Config.exportType.get() == 1
                                           else f"  <{tag}>{alreadyDefinedDict[tag]}</{tag}>")
                    del alreadyDefinedDict[tag]
                except KeyError:
                    writingTextList.append(f"  <!-- {text} -->\n  <{tag}>TODO</{tag}>"
                                           if Config.exportType.get() == 1
                                           else f"  <{tag}>{text}</{tag}>")

            with open(filename, 'w', encoding='UTF8') as fin:
                fin.write("""<?xml version="1.0" encoding="utf-8"?>\n<LanguageData>\n""")
                fin.write('\n'.join(writingTextList))
                if Config.collisionOption.get() == 2 and alreadyDefinedDict:  # collision -> merge
                    fin.write("\n\n  <!-- 알파의 추출기는 추출하지 않았지만 이미 존재했던 노드들 \n\n")
                    for tag, text in alreadyDefinedDict.items():
                        if type(text) == list:
                            fin.write(f"  <{tag}>\n")
                            fin.write('\n'.join([f"    <li>{eachText}</li>" for eachText in text]))
                            fin.write(f"\n  </{tag}>\n")
                        else:
                            fin.write(f"  <{tag}>{text}</{tag}>\n")
                    fin.write("  -->")
                fin.write("\n</LanguageData>")

            savedList.append("Keyed")

        # Strings
        for departure in Config.list_strings:
            destination = Config.exportDirName.get() + f"/Languages/{LANGUAGE}/" + \
                          departure.split('Languages\\English')[1]
            if Config.collisionOption.get() != 1:  # collision -> not overwrite
                try:
                    with open(destination, 'r', encoding='UTF8') as _:
                        return 1, ("Strings", WORD_NEWLINE.join(savedList))
                except FileNotFoundError:
                    pass

            Path('\\'.join(destination.split('\\')[:-1])).mkdir(parents=True, exist_ok=True)
            shutil.copy(departure, destination)

        if Config.list_strings:
            savedList.append("Strings")

        return 0, savedList


    def exportXlsx():
        filename = Config.exportDirName.get() + '/' + Config.exportFileName.get() + '.xlsx'

        alreadyDefinedDict = {}
        if os.path.exists(filename):
            if Config.collisionOption.get() == 0:  # collision -> stop
                return 1
            if Config.collisionOption.get() > 1:
                with open(filename, "rb") as f:
                    ioFile = io.BytesIO(f.read())
                ws = load_workbook(ioFile, read_only=True).active
                for row in ws.iter_rows(min_row=2, min_col=2, max_col=5, values_only=True):
                    if any(row):
                        try:
                            alreadyDefinedDict[row[0]][row[1]] = row[3]
                        except KeyError:
                            alreadyDefinedDict[row[0]] = {row[1]: row[3]}

        try:
            Path('/'.join(filename.split('/')[:-1])).mkdir(parents=True, exist_ok=True)
        except NotADirectoryError:
            return 4

        wb = Workbook()
        ws = wb.active

        writingList = [(className, tag, text)
                       for className, tag_dict in dict_class.items()
                       for tag, (lastTag, text) in tag_dict.items()
                       if lastTag in Config.includes]

        writingList += [('Keyed', tag, text) for tag, text in dict_keyed.items()]

        fill = PatternFill(fill_type='solid', fgColor='ffffff')

        ws.cell(row=1, column=1).value = "Class+Node [(Identifier (Key)]"
        ws.cell(row=1, column=2).value = "Class [Not chosen]"
        ws.cell(row=1, column=3).value = "Node [Not chosen]"
        ws.cell(row=1, column=4).value = "EN [Source string]"
        ws.cell(row=1, column=5).value = "KO [Translation]"
        for j in range(1, 6):
            ws.cell(row=1, column=j).fill = fill

        for i, (className, tag, text) in enumerate(writingList):
            ws.cell(row=i + 2, column=1).value = className + '+' + tag
            ws.cell(row=i + 2, column=2).value = className
            ws.cell(row=i + 2, column=3).value = tag
            ws.cell(row=i + 2, column=4).value = text
            for j in range(1, 6):
                ws.cell(row=i + 2, column=j).fill = fill

            if alreadyDefinedDict:
                try:
                    ws.cell(row=i + 2, column=5).value = alreadyDefinedDict[className][tag]
                    ws.cell(row=i + 2, column=5).fill = fill
                except KeyError:
                    pass

        try:
            wb.save(filename)
        except PermissionError:
            return 2
        except OSError:
            return 3

        # Strings
        for departure in Config.list_strings:
            destination = Config.exportDirName.get() + departure.split('Languages\\English')[1]
            if Config.collisionOption.get() != 1:  # collision -> not overwrite
                try:
                    with open(destination, 'r', encoding='UTF8') as _:
                        return 1
                except FileNotFoundError:
                    pass

            Path('\\'.join(destination.split('\\')[:-1])).mkdir(parents=True, exist_ok=True)
            shutil.copy(departure, destination)

        return 0


    def export():
        if not Config.modName:
            messagebox.showerror("추출 모드가 선택되지 않음", "하! 이럴 인간이 있을 줄 알았지.")
            return
        if Config.exportType.get() != EXPORT_XLSX:
            result = exportXml()
            if result[0] == 0:
                messagebox.showinfo("퍼일 저장 완료",
                                    "작업이 완료되었습니다.\n새로 작성되거나 변경된 파일의 폴더 리스트는 아래와 같습니다.\n{}".format("\n".join(result[1])))
            elif result[0] == 1:
                messagebox.showerror("파일 충돌 발견됨",
                                     f"다음 폴더의 파일이 존재하여 작업을 중단하였습니다.\n{result[1][0]}\n\n" +
                                     f"이미 저장된 파일의 폴더 리스트는 아래와 같습니다.\n{WORD_NEWLINE.join(result[1][1])}")
            elif result[0] == 3:
                messagebox.showerror("파일 저장 오류", "출력 파일의 이름에서 \\ / : * ? \" < > | 중 하나 이상의 문자열이 발견되었습니다. 해당 문자열을 제거해 주세요.")
        else:
            result = exportXlsx()
            if result == 0:
                messagebox.showinfo("퍼일 저장 완료", "작업이 완료되었습니다.")
            elif result == 1:
                messagebox.showerror("파일 충돌 발견됨", "작업 폴더의 파일이 존재하여 작업을 중단하였습니다.")
            elif result == 2:
                messagebox.showerror("파일 저장 오류", "엑셀 파일이 열려있어(혹은 쓰기 금지되어) 저장에 실패하였습니다.")
            elif result == 3:
                messagebox.showerror("파일 저장 오류", "출력 파일의 이름에서 \\ / : * ? \" < > | 중 하나 이상의 문자열이 발견되었습니다. 해당 문자열을 제거해 주세요.")
            elif result == 4:
                messagebox.showerror("파일 저장 오류", "출력 폴더의 이름에서 \\ / : * ? \" < > | 중 하나 이상의 문자열이 발견되었습니다. 해당 문자열을 제거해 주세요.")
            return


    btn = Button(frame, text="5. 추출한 노드 출력하기", command=export)
    btn.grid(row=5, column=1, columnspan=2, padx=10, pady=5, sticky='NSWE')


    def convert_xlsx_2_xml():
        if filename := filedialog.askopenfilename(initialdir='./'):
            convertXLSX2XML(filename)


    convert_xlsx_2_xml_Btn = Button(frame, text="(XLSX -> XML)", command=convert_xlsx_2_xml)
    convert_xlsx_2_xml_Btn.grid(row=5, column=3, padx=10, pady=5, sticky='NSWE')

    def convert_xml_2_xlsx():
        if dirname := filedialog.askdirectory(initialdir='./'):
            convertXML2XLSX(dirname)


    convert_xml_2_xlsx_Btn = Button(frame, text="(XML -> XLSX)", command=convert_xml_2_xlsx)
    convert_xml_2_xlsx_Btn.grid(row=5, column=0, padx=10, pady=5, sticky='NSWE')
    convert_xml_2_xlsx_Btn['state'] = 'disabled'

    try:
        versionURL = "https://raw.githubusercontent.com/dlgks224/AlphaExtractor/master/CURRENT_VERSION"
        serverVersion = urllib.request.urlopen(versionURL).read().decode("utf-8").replace('\n', '')
        if EXTRACTOR_VERSION != serverVersion:
            if messagebox.askyesno("업데이트 가능",
                                   "새로운 버전의 추출기가 발견되었습니다.\n\n" +
                                   f"업데이트 버전 : {EXTRACTOR_VERSION} -> {serverVersion}\n\n다운로드 페이지를 열까요?"):
                import webbrowser

                webbrowser.open_new('https://github.com/dlgks224/AlphaExtractor/releases')
                exit(0)
    except (urllib.error.HTTPError, urllib.error.URLError):
        pass

    window.mainloop()
